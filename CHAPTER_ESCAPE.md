
## Chapter ESCAPE - Working Software
======================================

### Working software is magical. Users interact with working software in ways that can never be imagined from mocked up designs, or a list of specifications. Working software helps you discover value and create "pull" from users. Getting working software in the hands of users will give us the best chance of success. But for many reasons, it's often a struggle.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

> >>"sufficiently advanced technology is indistinguishable from magic"
>
> Arthur C. Clarke

At the turn of the millennium a bunch of men (they were all men) got
together in a Ski Lodge in Utah. There they wrote the Agile manifesto.
They were all people who had been struggling with a difficult question.
"How can we make project management of software development simpler and
more effective." They wanted something that was simple, lightweight and
increased the chances of success. That's maybe why the manifesto itself
isn't a big, complicated thing. It's sixty eight words long. In the
Agile manifesto, there are four key values. Working software is talked
about as the second key value.

> "Working software over comprehensive documentation."

Right after:

> "Individuals and interactions over processes and tools."

The primary message of the Agile manifesto is "people first", good
software comes out of discussions between people. Conversations between
people? Well, that's certainly one description of the user and
stakeholder research that we talk about in [Chapter SWAMP]. But right
after that, the founding fathers of Agile talk about working software.

Why? Why do we think that might be? Those guys, who got together to talk
about "lightweight" software methodologies, what was their experience?
What from their experience caused them to mention "working software" as
one of their four values.

My guess is that they had all had experience of projects where the
delivery of working software had been delayed or had never happened.
They had worked on projects where months or years could go by before a
specification was agreed, and finally software development could start.
Then they'd waited maybe more months or years before any of the people
who were supposed to use the software got to touch it.

For the first forty or fifty years that software development existed,
that's how people thought it should be done. Software development was
called software engineering and it was thought to be an offshoot of
other kinds of engineering. In other kinds of engineering, at least in
theory, nothing is built before the production of detailed plans.

This is what makes the second principle of the Agile manifesto so
revolutionary. It is saying the engineering equivalent of "have a go at
building a bridge and see how you get on." And, "as soon as you've got a
prototype, let people have a go at driving over it." Of course, this
isn't how bridges should work.

What these guys are saying in this tiny statement is that software works
differently, it isn't like building bridges. It has a different logic.
It has different needs.

The people who wrote the manifesto had experience of what happens if you
don't push for working software. Very often, when the software is
finally delivered, there are nasty surprises. It isn't what the users
want, or even, it was what the uses wanted several years ago when the
detailed specifications were written. But in the intervening time since
you started the project, the world has changed.

They might also have seen the huge benefits of getting working software
early.

So, what is it about working software that makes it so important?

One thing about working software is that it's magic. Let's just think
back to the quote at the beginning of this chapter. If there's anything
that counts as "sufficiently advanced technology," working software is
it. People definitely respond to it as if it is magic. People respond to
working software. They respond instantly. They respond automatically and
with emotions. When they press a button, or click on a picture, they
have an expectation of what will happen. Working software creates needs,
expectations and it evokes emotions: delight, joy, frustration and
anger. This is a very different response that the one you get from a
checklist of functionality in a requirements document. That means that
pretty much the only way to find out how users are going to respond, is
to put actual working software in their hands.

And when you do put software in their hands, users will find ways of
using it that you didn't expect, users will value aspects of the
software that you didn't expect. Remember the swamp? When you build
things in the swamp, you will start to discover value, people will use
what you've built in unexpected ways. You thought these were ornamental
ponds. People are swimming in them. You thought these buildings you put
up were just fishing huts. People are living in them all year round.
When you dig a hole in a place that isn't well understood, you will find
things that you didn't expect. People will react to your software in
ways that you didn't expect, and they'll want it to do more than it
currently does in directions that you didn't expect. When people like
something, they want more of it. And this leads to something called
"pull".

Pull is the second powerful thing about putting working software in the
hands of users. Up to the point where users find something in your
software that they like, that helps them get done what they want or need
to do, your project has been in "push" mode. The sole driver for the
functionality in your software was the stakeholders who had originated
the project.

Now you have users, and they have things that they want. You are in
"pull mode". This doesn't mean necessarily that you should give users
everything that they want, but it does mean that the dynamic of the
project has changed.

And this is a huge change. It means that your project has moved from
being just someone's idea to something that people actually want,
something that has value. This might not be the only possible criteria
for success, but it's certainly one of the most important.

And this is one of the most important reasons for making working
software available as soon as possible. When we make working software
available early, we're giving it the opportunity of connecting with its
audience. We're trying to create "pull". to be guided by the people who
are using it in how to make it deliver more and more value.

But there other very good reasons for making your software available as
soon as possible. And one of them is perhaps best explained using a
joke.

> You will never be alone if you take with you everywhere the
> ingredients and equipment to make a martini. Even if you think you are
> completely desolate and stranded on a desert island. Because the
> minute that you start to make the dry martini, someone will jump out
> from behind a tree and say, "that's not how you make a martini."

Something like this is true of developing working software. Ideally, you
want your software to be in the environments where it will finally be
used. That means running on the computers that it's going to be running
on when it's live. You want it to be accessible to real users. You want
them to be able to use their real data, on the real software. But the
truth is that the nearer you get to doing that, the more likely it is
that people that you didn't even know existed will jump out from behind
trees. These people will tell you that "you're doing it wrong" and try
to stop you getting working software in the hands of users.

In my head, I always imagine the job of getting working software out in
the world, on a working environment, like trying to escape from a prison
camp. There's only one way to find out what all the traps are that are
out there in no man's land, and that's to try to set them off.

OK, I'm mixing metaphors. Let's stick with the man behind a tree for a
moment. Most of those things that the man who jumps out from behind a
tree will bring up are called "non-functional requirements." These are
requirements that the software needs to meet but which aren't strictly
about the thing that it does. The software needs to be accessible to
users with visual impairments. The software needs to be secure. The
software needs to comply with a bunch of regulations specific to a
particular industry.

One way to tackle all the rules and regulations that your software might
contravene is to try to take care of them in the specification. Before
any software gets written you might try to think of everything that
might possibly be required. But in my experience, it's very hard to find
out exactly what you can and can't do without trying to do something. We
can guess that the framers of the Agile manifesto had had similar
experiences.

When you're trying to list these requirements without a piece of working
software, you're only dealing "known knowns" and you can to some degree
draw a circle around "known unknowns". When you try to get some working
software as far as you can through the barbed wire to the outside world,
you soon start to be surprised by "unknown unknowns". You knew there
would be other security measures out there in no man's land, but you
didn't know what they were. And for some of those things, there really
was only one way to find out.

This is the counter-intuitive thing that I'm trying to tell you that is
so important that the founding fathers of Agile put it number two in
their manifesto. You should try to get working software as near as you
can to live. Why? Because if you do a man will jump out from behind a
tree and tell you why you can't. The only real way to find out what
there is in no-man's land, or "man jumping out from behind a tree" land,
is to go there.

By actually getting your software into the hands of users, you will
certainly here from those who try to stop you. But you will also get the
answers to a whole bunch of other questions.

Is your team capable of writing this software?

Does your team have access to the tools and resources that they need to
write this software?

Does the technology that you've decided to use work?

Is the organisation that you're working for capable and willing to pay
for the servers, people and set-up that you need to deploy this
software?

Does the organisation that you're working for have any better idea of
what constitutes "secure" that just that word? Do they have, not only a
process for assessing that a piece of software is secure, but also a
process for agreeing that something is secure so that it can be
released?

I worked on a project for an organisation that was still doing pretty
much all of its business using paper documents. This was a huge
organisation, and it processed a lot of paper. The project that I was
working on looked at just one of these paper processes. The aim was to
take it over and make it manageable using an electronic document
handling and storage system.

And the project had a couple of good things going for it. Firstly, it
was using an Agile way of doing things. Secondly, the product owner was
a former clerk of the company. She knew all the other clerks and she
knew their business very well.

Even so, to start with the project had a tough time. We couldn't get
servers to put the software on. The open-source document package we'd
chosen wasn't as mature as we thought. But we pushed on through some
early design iterations. We dealt with a load of technical problems.
Finally, we got to one show and tell where the team had "working
software" that they could show.

It was an odd turning point in the project. Because that first demo was
so terrible. We'd managed to pare down the demo to a view of a
collection of documents and then a display of the document when its
title was clicked. In that first demo, when we clicked on the document
link, a window came up that said "Do you want to veiw [sic] your
document?" Yes, with that spelling mistake. And then when the user
clicked "OK" an error message appeared.

The look on the product owner's face! At this point we were about half a
million pounds into a two million pounds project. And all she had to
show was a misspelled dialog box that led to an error message. It was a
hard time for her. It was extremely embarrassing for the team.

But two weeks later it was a slightly different story. Now there was a
list of documents. Now when the document was clicked, the chance to open
the document had a button that was spelled correctly. And when it was
clicked, the document was displayed!

The product owner seemed a little bit more relaxed.

Not too many "show and tells" after that, the product owner had a
question. "Can I get this on a laptop so I can show it to the clerks?"

The short answer to that question was "no," because all of this nearly
half a million pounds worth of software was deployed only on developer
laptops. But the product owner's request to have a version that she
could take around the country and to show off was a powerful step in the
right direction. If we could actually do it, it provided a good extra
reason to negotiate with the people who were supposed to be giving us
server space.

Once the software was on her laptop, the product owner went on the road.
The demo still wasn't much. The demo still had bugs. We still had some
spelling problems! But the demonstration by the product owner to her own
former workmates went very well. She could wave past any user interface
issues, or problems. She could show the other clerks first sight of
something that could make their lives a lot easier.

She came back with a list of problems she'd come across while using the
demo. She also had a list of suggestions for features that had come from
the clerks. But she also came back with one important question - "When
will it be ready?"

From that point on, the nature of the project changed. It wasn't about
delivering on a list of functions. It was about rolling out to the
clerks all across the country the tiny bit of working software that the
product owner had shown them. Suddenly the road of what we needed to do
rolled out before us, with the people we were delivering to cheering us
on.

There was another very interesting thing about getting some working
software in front of the people who might use it. By doing this we both
asked and then started to answer the two questions that I've already
talked about. "Can we do this?" and "Who is going to jump out and stop
us if we do?"

To the first question, the answer at first was "No." We didn't have any
server space where we could deploy a live service. This was blocked
because of a dispute. The price of providing and supporting the servers
was not included in the original contract. But the client argued, that
they shouldn't have to commission the servers. Neither should they pay
for them or support them. This became a much harder argument to make
once people in their own company were asking for the software.

Suddenly the people who were trying to negotiate free stuff were in the
way of their own colleagues. Now they weren't helping the company by
being tough on costs. Rather they were stopping people who worked for
their organisation from getting something they wanted. Something that
could make their lives easier. Suddenly the servers appeared, and then
money for people to support the servers appeared. A real roll-out of the
software started to happen.

To the second question, "If we try to do this, is anybody going to jump
out from behind a tree and stop me?" The answer was "yes." In fact, two
people jumped out. An accessibility guy and a security guy. The
accessibility guy claimed that there was no way the software could be
released until it met an extra set of requirements. The client claimed
that we should have known about these requirements right from the start
and so we should pay for them.

And by the way, the client was right. We should have built in
accessibility right from the start. It takes no more effort in coding to
make sure that a website is accessible. And it actually makes the site
much easier for all kinds of people to use. People who you might not
think of as disabled. Do it. It makes sense. If in doubt, pay a blind
guy to look at your site. Does this sound insensitive? I really don't
think it is, but maybe that's because I know several blind guys who
dearly wish that people would ask a blind guy to look at their site.

Out from behind another tree jumped the security guy. He said that the
project should never be allowed to go live until we could prove that it
was secure. Just to leave us in no doubt about his effectiveness as a
blocker, he also refused to tell us what it was we needed to change so
that it would be secure. And of course, the costs of any changes we made
needed to be borne by us rather than the client.

As people who jump out from behind trees trying to block progress go,
these two looked pretty effective. Both were telling us we couldn't
release until we did what they said, both were telling us that we had to
pay to do what they said. The security guy was being even more effective
at blocking us because he was also not telling us what it was that we
had to do.

But neither of these guys was a match for the clerks. There were a lot
of clerks. They'd seen that this software would make their lives much
easier. We kept gradually improving the accessibility, but we went live
with what we had. We submitted the software to outside security testing.
We addressed the most serious issues that arose, but we went live with
some others still being looked at.

Putting bad software that just about worked in front of real users
completely changed the project. Why? Because it started to put together
the "virtuous" value stream that we talked about in [chapter
"STREAMS."] Putting real working software in front of real users
created pull. And that completely changed the dynamic (and control) of
the project.

Please pay attention to this because it's important. This is how you
deliver the impossible. This is how you make a project that seems
impossible, possible. You build something, you put in it the hands of
users, you start to get pull. From that point on, the dynamic of the
project has completely change. Your project is starting shift from being
a dream to being a reality.

How do you do this on your project? Every project is a little bit
different. But I'm going to arbitrarily invent a rule of sixths. This
feels about right. If you think your project is about 6 months long,
I'll give you a month to do some set up. If, not long after a month, you
and your team don't have *something* that works, you've waited too long.
By the end of a sixth of the time, you need a tiny piece of working
software. A small bit of software that starts to do the thing that it's
supposed to be doing. And you need to be able to show this software to
the people who will finally use it.

And once you've got this tiny little thing, you should be looking to
"promote its status" in some way. By that, I mean get the software being
used by more users. Or set the software up so that it's using live, or
like-live data. Or make it's deployment more automatic so it can run on
more than one machine and in more than one environment.

What's important with working software, at least at the beginning, is
not so much the content of what you've got, but that you've got
*something* and it's moving in all the right directions. Sure, it needs
to be increasing in terms of what it can do. But it also needs to be
moving from developer environments, to test environments and onto live
environments. And it needs to be moving from being tested by the team to
being tested by "friendly" users to being used by complete strangers. If
it's a business application, it needs to move from using dummy data, to
using data that looks like live data, to using real data.

I know nothing about rock climbing. But this seems to me to be a little
bit like if you're climbing a huge rock face. You climb a bit, then you
put in one of those things that holds the rope to the rock. Then you
pull on it, to make sure it's firm and would hold you if you fell, then
you can climb a bit more.

Yes, delivering software is a bit like that. It's a bit like climbing a
rock face (and it's like escaping a prison camp, and there's a guy
jumping out from behind a tree, I know, I know, too many metaphors). The
odd thing is how many people think that you can get to the top without a
rope. Even odder are the people who somehow imagine that you can get to
the top of the cliff in one single bound.

Gradually developing working software in all of those directions -
environment, security, audience, reality of data - is the careful and
effective way to deliver something. Especially if that something seems
impossible. And if the thing that you're doing is in any way useful or
interesting to the people who will use it, at some point you will start
to get "pull". Obviously, you'd like this sooner rather than later. But
at some point, you will start to get demand for the software. And then
you will start to get demand for more functionality from the software.
Not from the people who sold the idea -- that's "push" - but from the
people who are likely to use it - magical "pull".

And of course, gradually developing software in these directions will
also result in people jumping out from behind trees. They will ask you
about extra rules and regulations that you need to follow. Also
sometimes, they'll tell you that you can't proceed until you're
certified. How do you get certified? Oh that, they don't know.

You will need to negotiate these obstacles before your software can
finally escape and live free in the real world. Push working software as
far as you can towards being live with real users with real data. It's
the most powerful secret to actually delivering things that seem
impossible. But everybody, or nearly everybody, it will feel like
everybody, will try to stop you doing it, even people you thought were
your friends, colleagues and allies

Yes, that's right. Incrementally delivering working software is the
thing that you need to do. It's the thing that's most likely to help
your project succeed. Still, nearly everybody will try to stop you doing
it.

How? Why?

Let's deal with the how and the why separately.

How? Developers will tell you that there's no point breaking big bits of
functionality into smaller bits. Even though, those bits could be shown,
released and tested sooner. They'll say that it "only makes sense" to
release some bit of functionality in one big piece or in big sized
chunks.

How? Stakeholders will tell you that there's no point troubling users
with small bits of functionality. They'll tell you that users only want
to see the whole, finished, journey. They'll tell you that showing them
anything sooner is a waste of time and money, and users wouldn't
understand.

How? Some users will tell you that there's no point looking at the new
system until it has their real data in it. Some users will claim that
they're not interested in seeing the system until it can solve their
whole problem.

How? Stakeholders will tell you that test servers are expensive.

How? Stakeholders will tell you that the live environment is only in the
budget from the week before the project is scheduled to finish.

How? Product managers, even good product managers, that you like and
trust, they will utter the dread, tragic words "we need it all, so I
don't think it's important what order it gets done in."

But why? Why don't people want working software?

Why? I don't think the reasons people don't want working software are
the reason that they say they don't want it. At least, those aren't the
most important reason. The reason people don't want working software is
something we've already talked about. It's the same reason that the
improvisers that we talked about in [Chapter SHIP]. They don't want to
deal with the pirate ship. Without having to think about it, people know
that dealing with working software, or with the pirate ship that just
appeared on the horizon, will mean that they have to *change*. They will
have to change what they think. They also might have to change what they
do. We are all automatically, and subconsciously resistant to change.
Even if we work in managing projects or work in teams developing
software, or work as the manager of a software product, we instinctively
avoid change. Even though of course we are manifestly the business of
bringing about change.

Why? There's another important reason. Trying to get even a tiny bit of
software working tends to undermine some aspects of the idea. The
"flower" that we talk about in [Chapter STREAMS]. The thing that has
instant appeal. Suddenly that appeal is being examined. The point where
a team demonstrates working software for the first time is quite
possibly the point with the most stress and tension for the people who
got funding for the idea. It's the point that puts the idea of the
project under the most stress. It's awkward for the people who had the
idea. If just getting *something* to work takes so long, and that
*something* is so slow and has cost a lot of money. Suddenly the idea
doesn't look so shiny and appealing. It's also embarrassing for the
people who are delivering the software. After all the effort of project
setup, after all the fuss of setting up servers, arranging meetings this
tiny little thing is the first piece of working software.

Why? Another reason that people don't want to let software be free are
the "tree people". The people who jump out from behind trees and tell
you that things can't be done. Nobody wants to see them. Nobody wants to
deal with whatever extra requirements and regulations they place on your
project. The people who came up with the original idea don't want this
it's embarrassing for them if there are regulations that they hadn't
thought about. The team who are doing the development don't want this,
it's embarrassing for them if there are regulations that they haven't
met. It's utterly exhausting, dispiriting and Kafkaesque to be asked to
comply with regulations that nobody can find, or nobody can understand.

Moving towards working software does a whole lot of things that in
general people want to avoid. It throws up a lot of technical problems
that require thinking. It throws up a lot of rules, regulations and
restrictions about what can and can't be done that require even more
thinking. It makes obvious how slow and expensive it is to just get
*some* of a product. And in doing so, it tends to undermine the
"simple", "fast", "all", "cheap" appeal of the original "flower" of an
idea.

These are all very good reasons for not getting software working.
Getting software working throws up all kinds of surprises. It will
always be very tempting to stop.

You will start to feel these reasons for not doing working software. You
will see other people being persuaded by them. At this point it's really
important that you understand these reasons why you should carry on.

At any given point in a project and especially the first time that a
project does it, there are always good reasons *not* to release
anything. So, it's absolutely important to understand the even better
reasons why you should.

### You're going to have to do it sooner or later

And sooner is much better that later. Why? Because of all those problems
that you encounter when you start to deliver small amounts of software.
Encountering those problems early is a good thing. You will get problems
with the technology. You will get problems with moving the software from
one environment to another. You will start to hear of previously
unheard-of rules and regulations. You will get problems I haven't
thought of and problems you haven't thought of. There is no way around
all of those problems. The only way to deal with them is to get through
them. If you start to deliver something early, then you can deal with
these problems in bite size pieces. If you put off dealing with these
problems until later, you'll be forced to try to deal with them all at
once.

### Working software is another way of exploring the swamp

Delivering working software gives you enormous amounts of information
about the environment in which you're working. Putting working software
in front of potential users teaches you about your users. But trying to
get software onto live and "like live" environments also teaches you
about your stakeholders. All of the things that we talked about
exploring when we talked about the value of doing user research, all of
that exploration of the swamp, is complimented by the early and frequent
delivery of working software. All of the things that we wanted to know
about the swamp are further informed by the delivery of working
software. Who values this project? How is it seen in the rest of the
organisation? Who wants to stop it? Who wants to regulate it? Who is
this person who has suddenly started to turn up in your meetings who is
taking credit for it?

### You create "pull"

Sometimes, when you put working software in the hands of users you get a
response that you weren't expecting. "What the hell is this? This makes
no sense at all." Or even worse, apathy and silence. Nobody says
anything, everyone just ignores it.

This may not be pleasant. But when do you want to find out? You might be
grateful that you found this out when you were a small percentage of the
way into the project. You, your team and your stakeholder have only
spent a small amount of your time, money and resources. There's still
time to change direction, take account of the feedback and do some
things differently.

And having users object to your software, or even hate it, isn't
actually the worst response they can give. The worst response is utter
indifference. And even such a non-response as that is useful earlier
rather than later. Again, it's worth asking yourself, when would you, or
your sponsors like to find out that nobody cares about your project?
Now, when you've spent less than a quarter of the time and money that
you'd budgeted? Or later?

Of course, there's another response that you're hoping for if you put
small amounts of working software in the hands of users. If you're lucky
they will ask just one question - "When can I have this?" And then,
almost certainly, they will follow that up with "Could it do this? It
would be really nice if it also did this." This is what you're looking
for from working software. You're looking for pull. You're looking for a
way of prioritising the things that the software currently does and the
things that the software could do. And you want this based on actual
value to the users (fruit) rather than superficial appeal to the
internal sponsors and funders of a project (flowers). This is the start
of constructing the "virtuous" value stream that we talked about in
[Chapter STREAMS]

Once you've found something that users want, especially if it's
something that your software can provide, you will have made substantial
progress. You will have moved a long way down the road of moving a
project from impossible, to possible. But by doing that you've also made
the problem a lot more complicated. By trying to get software out into
the real world, you will probably have had people jump out from behind
trees. They will have told you that you're not allowed to put software
out into the real world. These people are now on the list of people that
you have to please. By putting working software in front of users, if
you're lucky, you'll have created demand and expectation. Now it's
obvious to you that you need to satisfy some of these demands and
expectations if this project is going to be a success.

What about the people who got this project funded? And what about the
people who actually funded it?

All of a sudden, they're not as in control of the project as they were,
the project has been let out into the wild world. It isn't just their
baby anymore. People may not react to this well. It may feel that you've
deliberately pushed you and your team and a project into a storm. Why on
earth did you do that? When they could have stayed in calmer waters.
Well, yes, that is exactly what you've done. This may feel a bit stupid,
so it's important to remember why you've done it. You've done it because
staying "safe" not being changed won't get you where you, your team and
your project need to be.

What's important as you move through these difficult waters, is to keep
pushing in the right direction. You need to keep pushing the working
software towards the real world, real users and real data. If what
you're doing is adding functionality to the software that can then be
tested with users, then good, you're going in the right direction. If
what you're doing is making the software fit better with non-functional
requirements, that's moving in the right direction. If what you're doing
is moving the software nearer to going live with live data and being
used by real users, then you're starting to make this project look
possible.

Do you know what? I think we might be nearly at the end of part one of
this book. Now might be time for a re-cap.

We started out by making it clear that this book is intended to help
project managers. Not all project managers. The focus is project
managers who are helping teams build projects that involve software
development. And for those project managers, the aim of this book is
even more focused. It is to transform projects from being impossible to
possible.

We admitted the challenging fact that lots of projects either start out
looking impossible or, because of various twists, turns and unexpected
events they end up looking impossible. But then we tried to cheer
ourselves us with a quote from the software pioneer Alan Kay -- "Point
of view is worth 80 IQ points." I'm making no claims for the
wholesomeness of IQ points. But according to that scale, this is
difference between being of average intelligence and being a genius.
This gave us just a tiny glimmer of hope. What if we could look at the
projects that we're trying to manage in a different way? Or maybe
*several different ways*. Maybe we can make some of these seemingly
impossible projects that we're working on seem possible?

And so on to our first point of view we looked at the pirate ship. Or
rather the point of view of an ordinary ship that's being approached by
a pirate ship. What should the crew do when they see a pirate ship on
the horizon? Well, they should admit that there's a pirate ship. What
should the captain and his officers do? They should try to work together
to figure out how to deal with the approaching catastrophe. What
shouldn't the crew do? They shouldn't scrub the decks and pretend that
the pirate ship isn't there. What shouldn't the captain do? They should
never, ever, tell the crew off for pointing out pirate ships. Even if
some of these "ships" turn out to be mirages. Because if they do, all
they'll get from that moment on from the crew is head down deck
scrubbing. Right up to the point where the captain is either forced to
walk the plan or go down with their ship.

Where do ideas come from? Nobody's really sure. They're like springs
that suddenly gush out of the ground as if apparently from nowhere. Of
course, we know that there must be a source be we're not sure we'll ever
know where it is. Where do successful products come from? Successful
products come from a value stream.

